<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Лодка — демо игра</title>
    <meta name="viewport" content="width=device-width,initial-scale=1">

    <style>
        /* ... все предыдущие стили остаются ... */

        /* Новый стиль для отображения текущего выигрыша */
        .live-win-display {
            position: absolute;
            top: -40px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 5;
            pointer-events: none;
            font-size: 20px;
            font-weight: 700;
            color: #7dff9d;
            text-shadow: 0 0 6px rgba(0,0,0,0.9);
            white-space: nowrap;
            transition: left 0.1s linear;
            opacity: 0;
        }

        .live-win-display.visible {
            opacity: 1;
        }
    </style>
</head>
<body>
<div class="game">
    
    <!-- ... остальной HTML (языковая панель, вода, стороны и т.д.) ... -->

    <!-- Лодка + шлейф + отображение выигрыша -->
    <div class="boat-area">
        <div class="live-win-display" id="liveWinDisplay">0.00 ₽</div>
        <div class="boat-wrap" id="boatWrap">
            <div class="boat-wake" id="boatWake"></div>
            <div class="boat" id="boat"></div>
        </div>
    </div>

    <!-- ... остальной HTML (результат, кнопка удержания, панель ставок) ... -->

</div>

<script>
    /* --- DOM ссылки (добавляем новую) --- */
    const liveWinDisplay = document.getElementById('liveWinDisplay');

    /* --- Состояние игры (добавляем) --- */
    let currentWin = 0;
    let currentBet = 0;

    /* -------- Обновление отображения текущего выигрыша -------- */
    function updateLiveWinDisplay() {
        currentWin = (currentBet || 0) * multiplier;
        const displayText = currentWin.toFixed(2) + ' ' + currencySymbol;
        liveWinDisplay.textContent = displayText;
    }

    /* -------- Позиционирование отображения выигрыша -------- */
    function positionLiveWinDisplay() {
        if (state !== 'running') return;
        
        const gameRect = gameEl.getBoundingClientRect();
        const boatRect = boatWrap.getBoundingClientRect();
        
        // Позиция по X относительно лодки
        const boatCenterX = boatRect.left + boatRect.width / 2;
        const displayLeft = boatCenterX - gameRect.left;
        
        // Ограничиваем, чтобы не выходило за экран
        const minX = 50;
        const maxX = gameRect.width - 50;
        const clampedX = Math.max(minX, Math.min(maxX, displayLeft));
        
        liveWinDisplay.style.left = clampedX + 'px';
        
        // Позиция по Y - фиксированная над лодкой
        const displayTop = boatRect.top - gameRect.top - 40;
        liveWinDisplay.style.top = displayTop + 'px';
    }

    /* -------- Инициализация выигрыша при старте -------- */
    function initLiveWin() {
        currentBet = getBet();
        updateLiveWinDisplay();
        positionLiveWinDisplay();
        liveWinDisplay.classList.add('visible');
    }

    /* -------- Скрытие отображения выигрыша -------- */
    function hideLiveWin() {
        liveWinDisplay.classList.remove('visible');
        currentWin = 0;
    }

    /* -------- Модифицированная функция startGrowing -------- */
    function startGrowing() {
        multiplier = 1;
        updateMultiplierUI();
        multiplierEl.classList.remove('hidden');
        boatEl.classList.add('moving');
        startBoatFrames();
        turning = true;
        boatTurnLoop();
        
        // Инициализируем отображение выигрыша
        currentBet = getBet();
        initLiveWin();

        growTimer = setInterval(() => {
            multiplier += 0.02;
            updateMultiplierUI();
            updateLiveWinDisplay(); // Обновляем выигрыш в реальном времени
        }, 40);
    }

    /* -------- Модифицированная функция обновления позиции лодки -------- */
    function boatTurnLoop() {
        if (!turning) return;
        boatOffsetX += (boatTargetOffsetX - boatOffsetX) * 0.18;
        applyBoatTransform();
        positionLiveWinDisplay(); // Обновляем позицию отображения выигрыша
        requestAnimationFrame(boatTurnLoop);
    }

    /* -------- Модифицированная функция handleBoatMove -------- */
    function handleBoatMove(e) {
        if (state !== 'running') return;
        if (e.pointerId !== activePointerId) return;
        e.preventDefault();

        const dx = e.clientX - dragStartX;
        maxBoatOffset = gameEl.clientWidth * 0.35;

        let target = dragStartOffset + dx;
        if (target >  maxBoatOffset) target =  maxBoatOffset;
        if (target < -maxBoatOffset) target = -maxBoatOffset;

        boatTargetOffsetX = target;
        positionLiveWinDisplay(); // Обновляем позицию при движении
    }

    /* -------- Модифицированная функция resetGame -------- */
    function resetGame() {
        state = 'idle';
        multiplier = 1;
        updateMultiplierUI();
        multiplierEl.classList.remove('hidden');

        resultBlock.classList.add('hidden');
        betMain.classList.remove('hidden');
        cashoutMain.classList.remove('visible');
        boatTargetOffsetX = 0;
        boatOffsetX = 0;
        applyBoatTransform();
        clearAllChests();
        hideLiveWin(); // Скрываем отображение выигрыша
    }

    /* -------- Модифицированная функция showResult -------- */
    function showResult() {
        const bet = getBet();
        const win = bet * multiplier;
        demoBalance += win;
        balanceValueEl.textContent = demoBalance.toFixed(2);
        resultMultEl.textContent = 'm' + multiplier.toFixed(2);
        lastMultEl.textContent   = multiplier.toFixed(2) + 'm';
        cashoutAmount.textContent = win.toFixed(2) + ' ' + currencySymbol;

        multiplierEl.classList.add('hidden');
        resultBlock.classList.remove('hidden');
        betMain.classList.add('hidden');
        cashoutMain.classList.add('visible');

        animateWinAmount(win);
        playSailAway();
        hideLiveWin(); // Скрываем отображение выигрыша
    }

    /* -------- Модифицированная обработка кнопки удержания -------- */
    holdBtn.addEventListener('pointerdown', (e) => {
        e.preventDefault();
        if (state !== 'idle') return;
        
        const bet = getBet();
        if (!bet) {
            betInput.classList.add('error');
            return;
        }
        
        if (!placeBet()) {
            return;
        }
        
        betInput.classList.remove('error');
        state = 'running';
        resultBlock.classList.add('hidden');
        boatWrap.classList.remove('sail-away');
        activePointerId = e.pointerId;
        holdBtn.setPointerCapture(e.pointerId);
        dragStartX = e.clientX;
        dragStartOffset = boatOffsetX;
        startGrowing();
        startBgScroll();
    });

    /* -------- Обновление валюты -------- */
    function updateCurrencyDisplay() {
        balanceValueEl.textContent = demoBalance.toFixed(2);
        
        const currentWin = parseFloat(resultWinEl.textContent) || 0;
        if (currentWin > 0) {
            resultWinEl.textContent = currentWin.toFixed(2) + ' ' + currencySymbol;
        }
        
        const cashoutCurrent = parseFloat(cashoutAmount.textContent) || 0;
        if (cashoutCurrent > 0) {
            cashoutAmount.textContent = cashoutCurrent.toFixed(2) + ' ' + currencySymbol;
        }
        
        // Обновляем отображение текущего выигрыша
        updateLiveWinDisplay();
    }

    /* -------- Обработка сундуков -------- */
    function checkChestCollisions() {
        if (state !== 'running') return;
        const boatRect = boatWrap.getBoundingClientRect();
        for (const ch of chests) {
            if (ch.state !== 'idle') continue;
            const r = ch.el.getBoundingClientRect();
            const overlap = !(
                r.right < boatRect.left ||
                r.left  > boatRect.right ||
                r.bottom< boatRect.top ||
                r.top   > boatRect.bottom
            );
            if (overlap) {
                startChestHitAnimation(ch);

                const bonus = 0.2 + Math.random() * 4.8;
                multiplier += bonus;
                updateMultiplierUI();
                updateLiveWinDisplay(); // Обновляем выигрыш при подборе сундука
                showChestBonus(ch, bonus);
            }
        }
    }

    /* -------- Инициализация -------- */
    // ... остальной код инициализации остается без изменений ...

</script>
</body>
</html>
